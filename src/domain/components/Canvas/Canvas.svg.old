// This version of <Canvas/> relies on SVG element for drawing and it stops drawing after a while
import "./Canvas.scss";
import { pfConfig } from "./config";
import { getStroke } from "perfect-freehand";
import { RootState, AppDispatch } from "@/store";
import { useEffect, useRef, useState } from "react";
import { useSelector, useDispatch } from "react-redux";
import { setCanvasSize } from "@/features/canvas/canvasSlice";

interface Point {
  x: number;
  y: number;
  pressure?: number;
}

function Canvas() {
  const dispatch = useDispatch<AppDispatch>();
  const canvasContainerRef = useRef<HTMLDivElement | null>(null);
  const [points, setPoints] = useState<Point[]>([]);
  const [paths, setPaths] = useState<string[]>([]);
  const { strokeColor, strokeWidth, canvasWidth, canvasHeight } = useSelector(
    (state: RootState) => state.canvas
  );

  useEffect(() => {
    const canvasContainer = canvasContainerRef.current;
    if (!canvasContainer) return;

    const resizeObserver = new ResizeObserver(() => {
      const { width, height } = canvasContainer.getBoundingClientRect();

      // Dispatch the new width and height to Redux
      dispatch(setCanvasSize({ width, height }));
    });

    // Observe the container for resizes
    resizeObserver.observe(canvasContainer);

    // Clean up the observer on unmount
    return () => resizeObserver.disconnect();
  }, [dispatch]);

  const handleStart = (e: MouseEvent | TouchEvent) => {
    e.preventDefault();
    const { x, y, pressure } = getPosition(e);
    setPoints([{ x, y, pressure }]);
  };

  const handleMove = (e: MouseEvent | TouchEvent) => {
    if ("buttons" in e && e.buttons !== 1) return;
    e.preventDefault();
    const { x, y, pressure } = getPosition(e);
    setPoints((prevPoints) => [...prevPoints, { x, y, pressure }]);
  };

  const handleEnd = () => {
    // When the drawing is finished, convert points to SVG path
    const newPath = generateSVGPath(points);
    if (newPath) {
      setPaths((prevPaths) => [...prevPaths, newPath]);
    }
    setPoints([]); // Clear points for the next stroke
  };

  const getPosition = (
    e: MouseEvent | TouchEvent
  ): { x: number; y: number; pressure: number } => {
    const canvasContainer = canvasContainerRef.current;
    if (!canvasContainer) return { x: 0, y: 0, pressure: 0.5 };

    const rect = canvasContainer.getBoundingClientRect();
    if (e instanceof TouchEvent) {
      const touch = e.touches[0];
      return {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top,
        pressure: touch.force || 0.5,
      };
    } else {
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top,
        pressure: 0.5, // Mouse events don't have pressure
      };
    }
  };

  // Function to convert points into an SVG path
  const generateSVGPath = (points: Point[]) => {
    const stroke = getStroke(
      points.map((p) => [p.x, p.y, p.pressure || 0.5]),
      pfConfig
    );
    if (!stroke.length) return "";
    let path = `M ${stroke[0][0]} ${stroke[0][1]}`;
    for (let i = 1; i < stroke.length; i++) {
      const [x, y] = stroke[i];
      path += ` L ${x} ${y}`;
    }
    return path;
  };

  useEffect(() => {
    const options = { passive: false };
    document.addEventListener("mousedown", handleStart, options);
    document.addEventListener("mousemove", handleMove, options);
    document.addEventListener("mouseup", handleEnd, options);
    document.addEventListener("touchstart", handleStart, options);
    document.addEventListener("touchmove", handleMove, options);
    document.addEventListener("touchend", handleEnd, options);

    return () => {
      document.removeEventListener("mousedown", handleStart);
      document.removeEventListener("mousemove", handleMove);
      document.removeEventListener("mouseup", handleEnd);
      document.removeEventListener("touchstart", handleStart);
      document.removeEventListener("touchmove", handleMove);
      document.removeEventListener("touchend", handleEnd);
    };
  }, [points]);

  return (
    <div
      ref={canvasContainerRef}
      className="canvas-container"
      style={{ width: "100%", height: canvasHeight }}
    >
      <svg className="canvas" width={canvasWidth} height={canvasHeight}>
        {/* Render all completed paths */}
        {paths.map((path, index) => (
          <path
            key={index}
            d={path}
            fill="none"
            stroke={strokeColor}
            strokeWidth={strokeWidth}
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        ))}

        {/* Render the current path being drawn */}
        {points.length > 0 && (
          <path
            d={generateSVGPath(points)}
            fill="none"
            stroke={strokeColor}
            strokeWidth={strokeWidth}
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        )}
      </svg>
    </div>
  );
}

export default Canvas;
